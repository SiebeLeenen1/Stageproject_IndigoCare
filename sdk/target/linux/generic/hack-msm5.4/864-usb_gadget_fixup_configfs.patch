Index: linux-msm5.4.244/drivers/usb/gadget/configfs.c
===================================================================
--- linux-msm5.4.244.orig/drivers/usb/gadget/configfs.c
+++ linux-msm5.4.244/drivers/usb/gadget/configfs.c
@@ -344,9 +344,6 @@ static ssize_t gadget_dev_desc_UDC_store
 			gi->composite.gadget_driver.udc_name = NULL;
 			goto err;
 		}
-#ifdef CONFIG_USB_CONFIGFS_UEVENT
-		schedule_work(&gi->work);
-#endif
 	}
 	mutex_unlock(&gi->lock);
 	return len;
@@ -524,33 +521,6 @@ static int config_usb_cfg_link(
 #endif
 	int ret;
 
-#ifdef QL_DATA_INTERFACE
-	int func_index = 0;
-	static const char net_func_name[][20] = 
-	{
-		{"gsi.rmnet"},
-		{"gsi.ecm"},
-		{"gsi.mbim"},
-		{"gsi.rndis"},
-		{"rndis.rndis"},
-		{"ipc.ipc"},
-		{"gsi.dpl"},
-		{""}
-	};
-#endif
-	
-#ifdef QL_DATA_INTERFACE
-	if (ql_get_net_interface() == QL_DATA_INTERFACE_PCIE) {
-		func_index = 0;
-		while (strlen(net_func_name[func_index])) {
-			if (strcmp(usb_func_ci->ci_name, net_func_name[func_index]) == 0) {
-				return ERR_PTR(-EINVAL);
-			}
-			func_index++;
-		}
-	}
-#endif
-
 	mutex_lock(&gi->lock);
 	/*
 	 * Make sure this function is from within our _this_ gadget and not
@@ -1471,7 +1441,6 @@ static void purge_configs_funcs(struct g
 		c->fullspeed = 0;
 	}
 }
-char QuecUsbProduct[]="LTE Module";
 static int configfs_composite_bind(struct usb_gadget *gadget,
 		struct usb_gadget_driver *gdriver)
 {
@@ -1483,7 +1452,6 @@ static int configfs_composite_bind(struc
 	struct usb_string		*s;
 	unsigned			i;
 	int				ret;
-    int	Queclen = 0;
 
 	/* the gi->lock is hold by the caller */
 	gi->unbind = 0;
@@ -1695,50 +1663,6 @@ static void configfs_composite_unbind(st
 	spin_unlock_irqrestore(&gi->spinlock, flags);
 }
 
-#ifdef CONFIG_USB_CONFIGFS_UEVENT
-static int android_setup(struct usb_gadget *gadget,
-			const struct usb_ctrlrequest *c)
-{
-	struct usb_composite_dev *cdev = get_gadget_data(gadget);
-	unsigned long flags;
-	struct gadget_info *gi = container_of(cdev, struct gadget_info, cdev);
-	int value = -EOPNOTSUPP;
-	struct usb_function_instance *fi;
-
-	spin_lock_irqsave(&cdev->lock, flags);
-	if (!gi->connected) {
-		gi->connected = 1;
-		schedule_work(&gi->work);
-	}
-	spin_unlock_irqrestore(&cdev->lock, flags);
-	list_for_each_entry(fi, &gi->available_func, cfs_list) {
-		if (fi != NULL && fi->f != NULL && fi->f->setup != NULL) {
-			value = fi->f->setup(fi->f, c);
-			if (value >= 0)
-				break;
-		}
-	}
-
-#ifdef CONFIG_USB_CONFIGFS_F_ACC
-	if (value < 0)
-		value = acc_ctrlrequest(cdev, c);
-#endif
-
-	if (value < 0)
-		value = composite_setup(gadget, c);
-
-	spin_lock_irqsave(&cdev->lock, flags);
-	if (c->bRequest == USB_REQ_SET_CONFIGURATION &&
-						cdev->config) {
-		schedule_work(&gi->work);
-	}
-	spin_unlock_irqrestore(&cdev->lock, flags);
-
-	return value;
-}
-
-#else // CONFIG_USB_CONFIGFS_UEVENT
-
 static int configfs_composite_setup(struct usb_gadget *gadget,
 		const struct usb_ctrlrequest *ctrl)
 {
@@ -1764,8 +1688,6 @@ static int configfs_composite_setup(stru
 	return ret;
 }
 
-#endif // CONFIG_USB_CONFIGFS_UEVENT
-
 static void configfs_composite_disconnect(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev *cdev;
@@ -1796,8 +1718,6 @@ static void configfs_composite_disconnec
 	}
 #ifdef CONFIG_USB_CONFIGFS_UEVENT
 	gi->connected = false;
-	if (!gi->unbinding)
-		schedule_work(&gi->work);
 #endif
 	composite_disconnect(gadget);
 	spin_unlock_irqrestore(&gi->spinlock, flags);
@@ -1869,137 +1789,6 @@ static const struct usb_gadget_driver co
 	.match_existing_only = 1,
 };
 
-#ifdef CONFIG_USB_CONFIGFS_UEVENT
-static ssize_t state_show(struct device *pdev, struct device_attribute *attr,
-			char *buf)
-{
-	struct gadget_info *dev = dev_get_drvdata(pdev);
-	struct usb_composite_dev *cdev;
-	char *state = "DISCONNECTED";
-	unsigned long flags;
-
-	if (!dev)
-		goto out;
-
-	cdev = &dev->cdev;
-
-	if (!cdev)
-		goto out;
-
-	spin_lock_irqsave(&cdev->lock, flags);
-	if (cdev->config)
-		state = "CONFIGURED";
-	else if (dev->connected)
-		state = "CONNECTED";
-	spin_unlock_irqrestore(&cdev->lock, flags);
-out:
-	return sprintf(buf, "%s\n", state);
-}
-
-static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
-
-
-
-#if defined(QL_G_PRODUCT_RG520FEUEA_TL_VA)/*@Duke-MarkFlag-20220906 USB Feature  for RG520FEUEA_TL_VA Project*/
-enum ql_usb_rndis_adaptive_state {
-   QL_ENABLE = 1,
-   QL_DISENABLE = 2,
-   QL_UNKNOWN_MAX = 3,
-};
-
-#define QL_USB_RNDIS_ADAPTIVE   QL_DISENABLE 
-static ssize_t ql_usb_rndis_adaptive_state_show(struct device *dev,struct device_attribute *attr, char *buf)	
-{
-	ssize_t	 status;
-	int	 value = QL_USB_RNDIS_ADAPTIVE;
-	status = sprintf(buf, "%d\n", value);
-	//printk("[quectel]rndis_adaptive state:%d\n",value);
-	return status;
-}
-
-static DEVICE_ATTR(ql_adaptive, S_IRUGO,ql_usb_rndis_adaptive_state_show, NULL)	;
-
-static unsigned char ql_ecm_trigger_signal = 0;
- int ql_ecm_send_usb_siwtch_signal_to_user(void)
-{
-	//printk("[quectel][usb]: send OS ecm msg event to user\n");
-	 ql_ecm_trigger_signal = 1;
-	
-	return 0;
-}
-
-static ssize_t  ql_ecm_trigger_state_show(struct device *dev,struct device_attribute *attr, char *buf)	
-{
-	ssize_t	 status;
-	int	 value = ql_ecm_trigger_signal;
-	status = sprintf(buf, "%d\n", value);
-	//printk("[quectel]rndis_adaptive state:%d\n",value);
-	return status;
-}
-
-static DEVICE_ATTR(ql_ecm_trigger, S_IRUGO,ql_ecm_trigger_state_show, NULL)	;
-#endif
-
-static struct device_attribute *android_usb_attributes[] = {
-	&dev_attr_state,
-#if defined(QL_G_PRODUCT_RG520FEUEA_TL_VA)/*@Duke-MarkFlag-20220906 USB Feature  for RG520FEUEA_TL_VA Project*/
-	&dev_attr_ql_adaptive,
-	&dev_attr_ql_ecm_trigger,
-#endif	
-	NULL
-};
-
-static int android_device_create(struct gadget_info *gi)
-{
-	struct device_attribute **attrs;
-	struct device_attribute *attr;
-
-	INIT_WORK(&gi->work, android_work);
-	gi->dev = device_create(android_class, NULL,
-			MKDEV(0, 0), NULL, "android%d", gadget_index++);
-	if (IS_ERR(gi->dev))
-		return PTR_ERR(gi->dev);
-
-	dev_set_drvdata(gi->dev, gi);
-	if (!android_device)
-		android_device = gi->dev;
-
-	attrs = android_usb_attributes;
-	while ((attr = *attrs++)) {
-		int err;
-
-		err = device_create_file(gi->dev, attr);
-		if (err) {
-			device_destroy(gi->dev->class,
-				       gi->dev->devt);
-			return err;
-		}
-	}
-
-	return 0;
-}
-
-static void android_device_destroy(struct gadget_info *gi)
-{
-	struct device_attribute **attrs;
-	struct device_attribute *attr;
-
-	attrs = android_usb_attributes;
-	while ((attr = *attrs++))
-		device_remove_file(gi->dev, attr);
-	device_destroy(gi->dev->class, gi->dev->devt);
-}
-#else
-static inline int android_device_create(struct gadget_info *gi)
-{
-	return 0;
-}
-
-static inline void android_device_destroy(struct gadget_info *gi)
-{
-}
-#endif
-
 static struct config_group *gadgets_make(
 		struct config_group *group,
 		const char *name)
@@ -2052,11 +1841,8 @@ static struct config_group *gadgets_make
 	if (!gi->composite.gadget_driver.function)
 		goto err;
 
-	if (android_device_create(gi) < 0)
-		goto err;
 
 	return &gi->group;
-
 err:
 	kfree(gi);
 	return ERR_PTR(-ENOMEM);
@@ -2064,11 +1850,7 @@ err:
 
 static void gadgets_drop(struct config_group *group, struct config_item *item)
 {
-	struct gadget_info *gi;
-
-	gi = container_of(to_config_group(item), struct gadget_info, group);
 	config_item_put(item);
-	android_device_destroy(gi);
 }
 
 static struct configfs_group_operations gadgets_ops = {
@@ -2101,180 +1883,6 @@ void unregister_gadget_item(struct confi
 }
 EXPORT_SYMBOL_GPL(unregister_gadget_item);
 
-#ifdef QL_FAST_USB
-extern int ql_ipa_load(void);
-
-struct {
-	struct work_struct work;
-	ql_usb_cfg_type usb_cfg;
-
-	struct config_group *g1;
-	struct config_group *c1;
-	struct config_group *mbim;
-	struct config_group *at;
-	struct config_group *strings_409;
-	struct gadget_strings *gs;
-	bool at_linked;
-	bool mbim_linked;
-
-} ql_fast_usb_struct;
-
-char serialno[12] = "123456789";
-static int __init init_usb_serialno(char *s)
-{
-	snprintf(serialno, sizeof(serialno), "%s", s);
-	serialno[11] = 0;
-	return 0;
-}
-__setup("androidboot.serialno=", init_usb_serialno);
-
-bool ql_need_fast_usb_config(ql_usb_cfg_type *usb_cfg)
-{
-	if (usb_cfg->net == USB_NET_MBIM) {
-		if (/* usb_cfg->func[USB_FUNC_AT] == 1 && */
-			usb_cfg->func[USB_FUNC_RMNET] == 1 && 
-			usb_cfg->func[USB_FUNC_DIAG] == 0 &&
-			usb_cfg->func[USB_FUNC_NMEA] == 0 &&
-			usb_cfg->func[USB_FUNC_MODEM] == 0 &&
-			usb_cfg->func[USB_FUNC_ADB] == 0) {// &&
-			// usb_cfg->func[USB_FUNC_AUDIO] == 0) {
-			// MBIM + GPS or MBIM only
-			return true;
-		}
-	}
-	return false;
-}
-#define QL_FAST_USB_FUNC_ENABLE(_name, _function_name, _symbol) \
-	_name = function_make(&gi->functions_group, (_function_name)); \
-	if (_name == NULL) { \
-		goto err; \
-	} \
-	ql_fast_usb_struct._name = _name; \
-	strcpy(f_dentry.d_iname, _symbol); \
-	if (config_usb_cfg_link(&c1->cg_item, &_name->cg_item) < 0) { \
-		pr_err("[jerry] config_usb_cfg_link fail\n"); \
-		goto err;		 \
-	} \
-	ql_fast_usb_struct._name##_linked = true;
-
-static void ql_fast_usb_work_func(struct work_struct *work)
-{
-	struct gadget_info *gi;
-	struct gadget_strings *gs;
-	struct config_group *g1, *c1, *mbim, *at, *strings_409;
-	struct dentry f_dentry = {};
-	g_ql_current_allow_link_dentry = &f_dentry;
-	ql_usb_cfg_type *usb_cfg = &ql_fast_usb_struct.usb_cfg;
-
-	pr_err("[jerry] %s %d\n", __func__, __LINE__);
-
-	g1 = gadgets_make(NULL, "g1");
-	if (g1 == NULL) {
-		pr_err("[jerry] gadgets_make fail\n");
-		goto err;
-	}
-	ql_fast_usb_struct.g1 = g1;
-
-	gi = container_of(g1, struct gadget_info, group);
-	strings_409 = gadget_strings_strings_make(&gi->strings_group, "0x409");
-	if (strings_409 == NULL) {
-		goto err;
-	}
-	ql_fast_usb_struct.strings_409 = strings_409;
-
-	gs = container_of(strings_409, struct gadget_strings, group);
-	gi->cdev.desc.idVendor = usb_cfg->vid;
-	gi->cdev.desc.idProduct = usb_cfg->pid;
-	usb_string_copy(usb_cfg->usb_manuf_info, &gs->manufacturer);
-	usb_string_copy(usb_cfg->usb_product_info, &gs->product);
-	usb_string_copy(serialno, &gs->serialnumber);
-	ql_fast_usb_struct.gs = gs;
-
-	c1 = config_desc_make(&gi->configs_group, "c.1");
-	if (c1 == NULL) {
-		pr_err("[jerry] config_desc_make fail\n");
-		goto err;
-	}
-	ql_fast_usb_struct.c1 = c1;
-	to_config_usb_cfg(&c1->cg_item)->c.bmAttributes = 0xA0; // remote_wakeup
-
-	QL_FAST_USB_FUNC_ENABLE(mbim, "gsi.mbim", "f8");
-	if (usb_cfg->func[USB_FUNC_AT] == 1) {
-		// QL_FAST_USB_FUNC_ENABLE(at, "cser.dun.0", "f2");
-		QL_FAST_USB_FUNC_ENABLE(at, "gsi.gps", "f17");
-	}
-
-	msleep(2000); /* wait for mounting / filesystem */
-	ql_ipa_load();
-
-	if (gadget_dev_desc_UDC_store(&g1->cg_item, "a600000.dwc3\n", 13) < 0) {
-		pr_err("[jerry] gadget_dev_desc_UDC_store fail\n");
-		goto err;
-	}
-
-	return;
-
-err:
-	if (ql_fast_usb_struct.mbim_linked) {
-		config_usb_cfg_unlink(&c1->cg_item, &ql_fast_usb_struct.mbim->cg_item);
-		ql_fast_usb_struct.mbim_linked = false;
-	}
-
-	if (ql_fast_usb_struct.at_linked) {
-		config_usb_cfg_unlink(&c1->cg_item, &ql_fast_usb_struct.at->cg_item);
-		ql_fast_usb_struct.at_linked = false;
-	}
-
-	if (ql_fast_usb_struct.mbim) {
-		function_drop(&gi->functions_group, &ql_fast_usb_struct.mbim->cg_item);
-		ql_fast_usb_struct.mbim = NULL;
-	}
-
-	if (ql_fast_usb_struct.at) {
-		function_drop(&gi->functions_group, &ql_fast_usb_struct.at->cg_item);
-		ql_fast_usb_struct.at = NULL;
-	}
-
-	config_group_init(&gadget_subsys.su_group);
-	configfs_register_subsystem(&gadget_subsys);
-	return;
-}
-
-static int __init gadget_cfs_init(void)
-{
-	int ret = 0;
-
-#ifdef CONFIG_USB_CONFIGFS_UEVENT
-	android_class = class_create(THIS_MODULE, "android_usb");
-	if (IS_ERR(android_class))
-		return PTR_ERR(android_class);
-#endif
-
-//quectel-20220923, rawdata not ready, disable fast usb function for emmc project.
-#if defined(QL_RAW_FLASH_DATA) && !defined(QL_G_PRODUCT_STORAGE_EMMC)
-	if (get_bootmode(NULL) == 0 && 
-		memset(&ql_fast_usb_struct, 0, sizeof(ql_fast_usb_struct)) &&
-		quec_rawdata_get_item(RAW_DATA_USB_CFG, &ql_fast_usb_struct.usb_cfg) &&
-	    ql_need_fast_usb_config(&ql_fast_usb_struct.usb_cfg)) {
-
-		INIT_WORK(&ql_fast_usb_struct.work, ql_fast_usb_work_func);
-		schedule_work(&ql_fast_usb_struct.work);
-	} else {
-	    config_group_init(&gadget_subsys.su_group);
-		ret = configfs_register_subsystem(&gadget_subsys);
-	}
-#else
-	{
-		config_group_init(&gadget_subsys.su_group);
-		ret = configfs_register_subsystem(&gadget_subsys);
-	}
-#endif
-	return ret;
-}
-late_initcall(gadget_cfs_init);
-
-#else // QL_FAST_USB
-
 static int __init gadget_cfs_init(void)
 {
 	int ret;
@@ -2292,7 +1900,6 @@ static int __init gadget_cfs_init(void)
 	return ret;
 }
 module_init(gadget_cfs_init);
-#endif // QL_FAST_USB
 
 static void __exit gadget_cfs_exit(void)
 {
Index: linux-msm5.4.244/drivers/usb/gadget/function/rndis.c
===================================================================
--- linux-msm5.4.244.orig/drivers/usb/gadget/function/rndis.c
+++ linux-msm5.4.244/drivers/usb/gadget/function/rndis.c
@@ -915,10 +915,6 @@ struct rndis_params *rndis_register(void
 
 			return ERR_PTR(-EIO);
 		}
-		//quectel for radio user(QCMAP) can access this proc node
-		kuid_t proc_kuid = make_kuid(&init_user_ns, 1001);
-		kgid_t proc_kgid = make_kgid(&init_user_ns, 1001);
-		proc_set_user(proc_entry, proc_kuid, proc_kgid);
 	}
 #endif
 
Index: linux-msm5.4.244/drivers/usb/gadget/function/u_ether.c
===================================================================
--- linux-msm5.4.244.orig/drivers/usb/gadget/function/u_ether.c
+++ linux-msm5.4.244/drivers/usb/gadget/function/u_ether.c
@@ -17,6 +17,7 @@
 #include <linux/etherdevice.h>
 #include <linux/ethtool.h>
 #include <linux/if_vlan.h>
+#include <linux/usb/composite.h>
 
 #include "u_ether.h"
 
@@ -550,15 +551,15 @@ static netdev_tx_t eth_start_xmit(struct
 		if (dev->port_usb)
 			skb = dev->wrap(dev->port_usb, skb);
 		spin_unlock_irqrestore(&dev->lock, flags);
-	}
-	if (!skb) {
-		/* Multi frame CDC protocols may store the frame for
+		if (!skb) {
+			/* Multi frame CDC protocols may store the frame for
 		 * later which is not a dropped frame.
 		 */
-		if (dev->port_usb &&
-				dev->port_usb->supports_multi_frame)
-			goto multiframe;
-		goto drop;
+			if (dev->port_usb &&
+			    dev->port_usb->supports_multi_frame)
+				goto multiframe;
+			goto drop;
+		}
 	}
 
 	length = skb->len;
@@ -653,8 +654,6 @@ static int eth_stop(struct net_device *n
 		dev->net->stats.rx_errors, dev->net->stats.tx_errors
 		);
 
-	usb_gadget_autopm_get(dev->gadget);
-
 	/* ensure there are no more active requests */
 	spin_lock_irqsave(&dev->lock, flags);
 	if (dev->port_usb) {
@@ -687,7 +686,6 @@ static int eth_stop(struct net_device *n
 		}
 	}
 	spin_unlock_irqrestore(&dev->lock, flags);
-	usb_gadget_autopm_put_async(dev->gadget);
 
 	return 0;
 }
@@ -776,9 +774,12 @@ struct eth_dev *gether_setup_name(struct
 	dev->qmult = qmult;
 	snprintf(net->name, sizeof(net->name), "%s%%d", netname);
 
-	if (get_ether_addr(dev_addr, net->dev_addr))
-		dev_warn(&g->dev,
-			"using random %s ethernet address\n", "self");
+	if (get_ether_addr(dev_addr, net->dev_addr)) {
+		net->addr_assign_type = NET_ADDR_RANDOM;
+		dev_warn(&g->dev, "using random %s ethernet address\n", "self");
+	} else {
+		net->addr_assign_type = NET_ADDR_SET;
+	}
 	if (get_ether_addr(host_addr, dev->host_mac))
 		dev_warn(&g->dev,
 			"using random %s ethernet address\n", "host");
@@ -835,6 +836,9 @@ struct net_device *gether_setup_name_def
 	INIT_LIST_HEAD(&dev->tx_reqs);
 	INIT_LIST_HEAD(&dev->rx_reqs);
 
+	/* by default we always have a random MAC address */
+	net->addr_assign_type = NET_ADDR_RANDOM;
+
 	skb_queue_head_init(&dev->rx_frames);
 
 	/* network device setup */
@@ -872,7 +876,6 @@ int gether_register_netdev(struct net_de
 	g = dev->gadget;
 
 	memcpy(net->dev_addr, dev->dev_mac, ETH_ALEN);
-	net->addr_assign_type = NET_ADDR_RANDOM;
 
 	status = register_netdev(net);
 	if (status < 0) {
@@ -912,6 +915,7 @@ int gether_set_dev_addr(struct net_devic
 	if (get_ether_addr(dev_addr, new_addr))
 		return -EINVAL;
 	memcpy(dev->dev_mac, new_addr, ETH_ALEN);
+	net->addr_assign_type = NET_ADDR_SET;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(gether_set_dev_addr);
Index: linux-msm5.4.244/drivers/usb/gadget/legacy/inode.c
===================================================================
--- linux-msm5.4.244.orig/drivers/usb/gadget/legacy/inode.c
+++ linux-msm5.4.244/drivers/usb/gadget/legacy/inode.c
@@ -229,6 +229,7 @@ static void put_ep (struct ep_data *data
  */
 
 static const char *CHIP;
+static DEFINE_MUTEX(sb_mutex);		/* Serialize superblock operations */
 
 /*----------------------------------------------------------------------*/
 
@@ -362,6 +363,7 @@ ep_io (struct ep_data *epdata, void *buf
 				spin_unlock_irq (&epdata->dev->lock);
 
 				DBG (epdata->dev, "endpoint gone\n");
+				wait_for_completion(&done);
 				epdata->status = -ENODEV;
 			}
 		}
@@ -2012,13 +2014,20 @@ gadgetfs_fill_super (struct super_block
 {
 	struct inode	*inode;
 	struct dev_data	*dev;
+	int		rc;
 
-	if (the_device)
-		return -ESRCH;
+	mutex_lock(&sb_mutex);
+
+	if (the_device) {
+		rc = -ESRCH;
+		goto Done;
+	}
 
 	CHIP = usb_get_gadget_udc_name();
-	if (!CHIP)
-		return -ENODEV;
+	if (!CHIP) {
+		rc = -ENODEV;
+		goto Done;
+	}
 
 	/* superblock */
 	sb->s_blocksize = PAGE_SIZE;
@@ -2055,13 +2064,17 @@ gadgetfs_fill_super (struct super_block
 	 * from binding to a controller.
 	 */
 	the_device = dev;
-	return 0;
+	rc = 0;
+	goto Done;
 
-Enomem:
+ Enomem:
 	kfree(CHIP);
 	CHIP = NULL;
+	rc = -ENOMEM;
 
-	return -ENOMEM;
+ Done:
+	mutex_unlock(&sb_mutex);
+	return rc;
 }
 
 /* "mount -t gadgetfs path /dev/gadget" ends up here */
@@ -2083,6 +2096,7 @@ static int gadgetfs_init_fs_context(stru
 static void
 gadgetfs_kill_sb (struct super_block *sb)
 {
+	mutex_lock(&sb_mutex);
 	kill_litter_super (sb);
 	if (the_device) {
 		put_dev (the_device);
@@ -2090,6 +2104,7 @@ gadgetfs_kill_sb (struct super_block *sb
 	}
 	kfree(CHIP);
 	CHIP = NULL;
+	mutex_unlock(&sb_mutex);
 }
 
 /*----------------------------------------------------------------------*/
@@ -2122,4 +2137,3 @@ static void __exit cleanup (void)
 	unregister_filesystem (&gadgetfs_type);
 }
 module_exit (cleanup);
-
Index: linux-msm5.4.244/drivers/usb/gadget/function/Makefile
===================================================================
--- linux-msm5.4.244.orig/drivers/usb/gadget/function/Makefile
+++ linux-msm5.4.244/drivers/usb/gadget/function/Makefile
@@ -21,8 +21,8 @@ usb_f_ncm-y			:= f_ncm.o
 obj-$(CONFIG_USB_F_NCM)		+= usb_f_ncm.o
 usb_f_ecm-y			:= f_ecm.o
 obj-$(CONFIG_USB_F_ECM)		+= usb_f_ecm.o
-usb_f_ecm_q-y			:= f_ecm_q.o
-obj-y		+= usb_f_ecm_q.o
+#usb_f_ecm_q-y			:= f_ecm_q.o
+#obj-y		+= usb_f_ecm_q.o
 usb_f_phonet-y			:= f_phonet.o
 obj-$(CONFIG_USB_F_PHONET)	+= usb_f_phonet.o
 usb_f_eem-y			:= f_eem.o
