--- a/bgpd/bgp_attr.c
+++ b/bgpd/bgp_attr.c
@@ -1757,7 +1757,7 @@ int bgp_mp_reach_parse(struct bgp_attr_p
 
 		mp_update->afi = afi;
 		mp_update->safi = safi;
-		return BGP_ATTR_PARSE_EOR;
+		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_ATTR, 0);
 	}
 
 	mp_update->afi = afi;
@@ -2225,7 +2225,8 @@ static bgp_attr_parse_ret_t bgp_attr_unk
 }
 
 /* Well-known attribute check. */
-static int bgp_attr_check(struct peer *peer, struct attr *attr)
+static int bgp_attr_check(struct peer *peer, struct attr *attr,
+			  bgp_size_t length)
 {
 	uint8_t type = 0;
 
@@ -2234,8 +2235,9 @@ static int bgp_attr_check(struct peer *p
 	 * we will pass it to be processed as a normal UPDATE without mandatory
 	 * attributes, that could lead to harmful behavior.
 	 */
-	
-	if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag)
+
+	if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag &&
+	    !length)
 			return BGP_ATTR_PARSE_WITHDRAW;
 
 	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))
@@ -2261,10 +2263,9 @@ static int bgp_attr_check(struct peer *p
 	   are present, it should.  Check for any other attribute being present
 	   instead.
 	 */
-	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&
-	    CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)))
-		return type ? BGP_ATTR_PARSE_EOR
-			    : BGP_ATTR_PARSE_PROCEED;
+	if ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) &&
+		CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))
+		return BGP_ATTR_PARSE_PROCEED;
 
 	/* If any of the well-known mandatory attributes are not present
 	 * in an UPDATE message, then "treat-as-withdraw" MUST be used.
@@ -2290,7 +2291,7 @@ bgp_attr_parse_ret_t bgp_attr_parse(stru
 	int ret;
 	uint8_t flag = 0;
 	uint8_t type = 0;
-	bgp_size_t length;
+	bgp_size_t length = 0;
 	uint8_t *startp, *endp;
 	uint8_t *attr_endp;
 	uint8_t seen[BGP_ATTR_BITMAP_SIZE];
@@ -2523,12 +2524,6 @@ bgp_attr_parse_ret_t bgp_attr_parse(stru
 			ret = BGP_ATTR_PARSE_ERROR;
 		}
 
-		if (ret == BGP_ATTR_PARSE_EOR) {
-			if (as4_path)
-				aspath_unintern(&as4_path);
-			return ret;
-		}
-
 		/* If hard error occured immediately return to the caller. */
 		if (ret == BGP_ATTR_PARSE_ERROR) {
 			zlog_warn("%s: Attribute %s, parse error", peer->host,
@@ -2573,7 +2568,7 @@ bgp_attr_parse_ret_t bgp_attr_parse(stru
 	/* Check all mandatory well-known attributes are present */
 	{
 		bgp_attr_parse_ret_t ret;
-		if ((ret = bgp_attr_check(peer, attr)) < 0) {
+		if ((ret = bgp_attr_check(peer, attr, length)) < 0) {
 			if (as4_path)
 				aspath_unintern(&as4_path);
 			return ret;
--- a/bgpd/bgp_attr.h
+++ b/bgpd/bgp_attr.h
@@ -251,7 +251,6 @@ typedef enum {
 	/* only used internally, send notify + convert to BGP_ATTR_PARSE_ERROR
 	   */
 	BGP_ATTR_PARSE_ERROR_NOTIFYPLS = -3,
-	BGP_ATTR_PARSE_EOR = -4,
 } bgp_attr_parse_ret_t;
 
 struct bpacket_attr_vec_arr;
--- a/bgpd/bgp_packet.c
+++ b/bgpd/bgp_packet.c
@@ -1516,7 +1516,7 @@ static int bgp_update_receive(struct pee
 	/* Network Layer Reachability Information. */
 	update_len = end - stream_pnt(s);
 
-	if (update_len && attribute_len && attr_parse_ret != BGP_ATTR_PARSE_EOR) {
+	if (update_len) {
 		/* Set NLRI portion to structure. */
 		nlris[NLRI_UPDATE].afi = AFI_IP;
 		nlris[NLRI_UPDATE].safi = SAFI_UNICAST;
@@ -1579,8 +1579,7 @@ static int bgp_update_receive(struct pee
 	 * Non-MP IPv4/Unicast EoR is a completely empty UPDATE
 	 * and MP EoR should have only an empty MP_UNREACH
 	 */
-	if ((!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0)
-	    || (attr_parse_ret == BGP_ATTR_PARSE_EOR)) {
+	if ((!update_len && !withdraw_len && nlris[NLRI_MP_UPDATE].length == 0)) {
 		afi_t afi = 0;
 		safi_t safi;
 
@@ -1595,9 +1594,6 @@ static int bgp_update_receive(struct pee
 			   && nlris[NLRI_MP_WITHDRAW].length == 0) {
 			afi = nlris[NLRI_MP_WITHDRAW].afi;
 			safi = nlris[NLRI_MP_WITHDRAW].safi;
-		} else if (attr_parse_ret == BGP_ATTR_PARSE_EOR) {
-			afi = nlris[NLRI_MP_UPDATE].afi;
-			safi = nlris[NLRI_MP_UPDATE].safi;
 		}
 
 		if (afi && peer->afc[afi][safi]) {
